<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Contract Connection</title>
    <script src="https://unpkg.com/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .success { background: #2d5a2d; }
        .error { background: #5a2d2d; }
        .info { background: #2d4a5a; }
        pre { background: #333; padding: 10px; border-radius: 5px; overflow-x: auto; }
    </style>
</head>
<body>
    <h1>Contract Connection Test</h1>
    <div id="status"></div>
    <div id="results"></div>

    <script>
        const CONTRACTS = {
            GRID_NFT: '0xa87Eb64534086e914A4437ac75a1b554A10C9934',
            RECIPE_VAULT: '0x26FAd52658A726927De3331C5F5D01a5b09aC685',
            MODEL_REGISTRY: '0xe660455D4A83bbbbcfDCF4219ad82447a831c8A1'
        };

        const RPC_URL = 'https://sepolia.base.org';

        const GRID_NFT_ABI = [
            "function getCompleteArtwork(uint256 tokenId) view returns (tuple(uint256 modelId, uint256 recipeId, uint256 seed, uint16 steps, uint16 cfgTenths, uint16 width, uint16 height, uint8 tier, address worker, uint256 mintTimestamp, bool isReproducible), tuple(string prompt, string negativePrompt, string sampler, string scheduler, string ipfsHash))",
            "function totalMinted() view returns (uint256)",
            "function ownerOf(uint256 tokenId) view returns (address)"
        ];

        const RECIPE_VAULT_ABI = [
            "function getRecipe(uint256 recipeId) view returns (tuple(uint256 recipeId, bytes32 recipeRoot, bytes workflowData, address creator, bool canCreateNFTs, bool isPublic, uint8 compression, uint256 createdAt, string name, string description))",
            "function totalRecipes() view returns (uint256)"
        ];

        const MODEL_REGISTRY_ABI = [
            "function getModel(uint256 modelId) view returns (bytes32 modelHash, uint8 modelType, string memory fileName, string memory name, string memory description, bool isNSFW, uint256 sizeBytes, uint256 timestamp, address creator, bool inpainting, bool img2img, bool controlnet, bool lora, string memory baseModel, string memory architecture)",
            "function totalModels() view returns (uint256)"
        ];

        function addStatus(message, type = 'info') {
            const status = document.getElementById('status');
            const div = document.createElement('div');
            div.className = `status ${type}`;
            div.textContent = message;
            status.appendChild(div);
        }

        function addResult(title, data) {
            const results = document.getElementById('results');
            const div = document.createElement('div');
            div.innerHTML = `<h3>${title}</h3><pre>${JSON.stringify(data, null, 2)}</pre>`;
            results.appendChild(div);
        }

        async function testConnection() {
            try {
                addStatus('Connecting to Base Sepolia...', 'info');
                
                const provider = new ethers.providers.JsonRpcProvider(RPC_URL);
                const network = await provider.getNetwork();
                addStatus(`Connected to network: ${network.name} (Chain ID: ${network.chainId})`, 'success');

                // Test GridNFT
                addStatus('Testing GridNFT contract...', 'info');
                const gridNFT = new ethers.Contract(CONTRACTS.GRID_NFT, GRID_NFT_ABI, provider);
                
                const totalMinted = await gridNFT.totalMinted();
                addStatus(`GridNFT total minted: ${totalMinted}`, 'success');
                
                if (totalMinted > 0) {
                    try {
                        const owner = await gridNFT.ownerOf(1);
                        addStatus(`Token 1 owner: ${owner}`, 'success');
                        
                        const artwork = await gridNFT.getCompleteArtwork(1);
                        addResult('Token 1 Artwork Data', {
                            metadata: {
                                modelId: artwork[0].modelId.toString(),
                                recipeId: artwork[0].recipeId.toString(),
                                seed: artwork[0].seed.toString(),
                                steps: artwork[0].steps,
                                cfgTenths: artwork[0].cfgTenths,
                                width: artwork[0].width,
                                height: artwork[0].height,
                                tier: artwork[0].tier,
                                worker: artwork[0].worker,
                                mintTimestamp: artwork[0].mintTimestamp.toString(),
                                isReproducible: artwork[0].isReproducible
                            },
                            strings: {
                                prompt: artwork[1].prompt,
                                negativePrompt: artwork[1].negativePrompt,
                                sampler: artwork[1].sampler,
                                scheduler: artwork[1].scheduler,
                                ipfsHash: artwork[1].ipfsHash
                            }
                        });
                    } catch (error) {
                        addStatus(`Error getting token 1 data: ${error.message}`, 'error');
                    }
                }

                // Test RecipeVault
                addStatus('Testing RecipeVault contract...', 'info');
                const recipeVault = new ethers.Contract(CONTRACTS.RECIPE_VAULT, RECIPE_VAULT_ABI, provider);
                
                const totalRecipes = await recipeVault.totalRecipes();
                addStatus(`RecipeVault total recipes: ${totalRecipes}`, 'success');
                
                if (totalRecipes > 0) {
                    try {
                        const recipe = await recipeVault.getRecipe(1);
                        addResult('Recipe 1 Data', {
                            recipeId: recipe.recipeId.toString(),
                            name: recipe.name,
                            description: recipe.description,
                            canCreateNFTs: recipe.canCreateNFTs,
                            isPublic: recipe.isPublic,
                            creator: recipe.creator,
                            createdAt: recipe.createdAt.toString()
                        });
                    } catch (error) {
                        addStatus(`Error getting recipe 1 data: ${error.message}`, 'error');
                    }
                }

                // Test ModelRegistry
                addStatus('Testing ModelRegistry contract...', 'info');
                const modelRegistry = new ethers.Contract(CONTRACTS.MODEL_REGISTRY, MODEL_REGISTRY_ABI, provider);
                
                const totalModels = await modelRegistry.totalModels();
                addStatus(`ModelRegistry total models: ${totalModels}`, 'success');
                
                if (totalModels > 0) {
                    try {
                        const model = await modelRegistry.getModel(1);
                        addResult('Model 1 Data', {
                            modelHash: model.modelHash,
                            modelType: model.modelType,
                            fileName: model.fileName,
                            name: model.name,
                            description: model.description,
                            isNSFW: model.isNSFW,
                            sizeBytes: model.sizeBytes.toString(),
                            creator: model.creator,
                            inpainting: model.inpainting,
                            img2img: model.img2img,
                            controlnet: model.controlnet,
                            lora: model.lora,
                            baseModel: model.baseModel,
                            architecture: model.architecture
                        });
                    } catch (error) {
                        addStatus(`Error getting model 1 data: ${error.message}`, 'error');
                    }
                }

                addStatus('All tests completed!', 'success');

            } catch (error) {
                addStatus(`Connection failed: ${error.message}`, 'error');
            }
        }

        // Run test when page loads
        window.addEventListener('load', testConnection);
    </script>
</body>
</html>


